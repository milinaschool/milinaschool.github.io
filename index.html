<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>면접 연습 프로그램</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #f0ede8;
            min-height: 100vh;
            padding: 0;
            color: #1a1a1a;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #faf9f7;
            min-height: 100vh;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.08);
        }

        .header {
            background: #faf9f7;
            border-bottom: 1px solid #d8d4cf;
            padding: 24px 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 1.5em;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .tabs {
            display: flex;
            background: #faf9f7;
            border-bottom: 1px solid #d8d4cf;
            padding: 0 40px;
            gap: 2px;
        }

        .tab {
            padding: 14px 20px;
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.95em;
            color: #6b7280;
            transition: all 0.2s ease;
            border: none;
            background: transparent;
            border-bottom: 2px solid transparent;
            position: relative;
        }

        .tab:hover {
            color: #374151;
            background: #f0ede8;
        }

        .tab.active {
            color: #c97f66;
            border-bottom-color: #c97f66;
            background: transparent;
        }

        .tab-content {
            display: none;
            padding: 32px 40px;
            background: #faf9f7;
        }

        .tab-content.active {
            display: block;
        }

        /* 연습 탭 스타일 */
        .practice-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }

        .question-section {
            background: #faf9f7;
            padding: 0;
        }

        .category-selector {
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .category-selector label {
            font-weight: 500;
            color: #374151;
            font-size: 0.95em;
        }

        .category-selector select {
            padding: 8px 12px;
            border: 1px solid #d8d4cf;
            border-radius: 6px;
            font-size: 0.95em;
            cursor: pointer;
            background: white;
            color: #1a1a1a;
            transition: border-color 0.2s;
        }

        .category-selector select:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }

        .question-display {
            background: white;
            padding: 24px;
            border-radius: 8px;
            margin: 20px 0;
            min-height: 150px;
            border: 1px solid #e8e5e0;
        }

        .question-number {
            color: #6b7280;
            font-weight: 500;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .question-text {
            font-size: 1.25em;
            color: #1a1a1a;
            line-height: 1.6;
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #c97f66;
            color: white;
        }

        .btn-primary:hover {
            background: #b86f58;
        }

        .btn-record {
            background: #a85b47;
            color: white;
            font-size: 1em;
            padding: 12px 24px;
        }

        .btn-record:hover {
            background: #924d3a;
        }

        .btn-record.recording {
            background: #7c9473;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .btn-secondary {
            background: #e8e5e0;
            color: #374151;
            border: 1px solid #d8d4cf;
        }

        .btn-secondary:hover {
            background: #d8d4cf;
        }

        .btn-success {
            background: #7c9473;
            color: white;
        }

        .btn-success:hover {
            background: #6b8064;
        }

        .btn-danger {
            background: #c97f66;
            color: white;
        }

        .btn-danger:hover {
            background: #b86f58;
        }

        .btn-small {
            padding: 6px 14px;
            font-size: 0.875em;
        }
        
        .btn-icon {
             padding: 6px 8px;
             font-size: 0.8em;
             line-height: 1;
        }

        /* 토글 스위치 스타일 */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px;
            background: #f5f3f0;
            border-radius: 6px;
            border: 1px solid #e8e5e0;
        }

        .toggle-label {
            font-weight: 500;
            color: #374151;
            font-size: 0.95em;
            flex: 1;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: #d8d4cf;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #7c9473;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .toggle-description {
            font-size: 0.85em;
            color: #6b7280;
            margin-top: 4px;
        }

        /* 프리셋 카드 스타일 */
        .preset-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .preset-card {
            background: white;
            border: 2px solid #e8e5e0;
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .preset-card:hover {
            border-color: #c97f66;
            box-shadow: 0 4px 12px rgba(201, 127, 102, 0.15);
            transform: translateY(-2px);
        }
        
        .preset-card.active {
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.2);
        }
        
        .preset-card.active:hover {
            transform: translateY(0);
        }


        .preset-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 12px;
        }

        .preset-card-title {
            font-weight: 600;
            font-size: 1.05em;
            color: #1a1a1a;
            word-break: break-word;
            flex: 1;
        }

        .preset-card-meta {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 12px;
        }

        .preset-card-actions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #f0ede8;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .preset-save-section {
            background: #f5f3f0;
            padding: 16px;
            border-radius: 8px;
            border: 2px dashed #d8d4cf;
            margin-bottom: 20px;
        }

        .preset-save-section h4 {
            font-size: 1em;
            color: #374151;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .preset-input-group {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .preset-input-group input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #d8d4cf;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .preset-input-group input:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }


        .timer {
            background: #f5e6d3;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 1.5em;
            font-weight: 600;
            color: #8b5a3c;
            text-align: center;
            margin: 20px 0;
            border: 1px solid #e8d5bc;
        }

        .transcription-area {
            background: white;
            border: 1px solid #e8e5e0;
            border-radius: 8px;
            padding: 20px;
            min-height: 150px;
            margin: 20px 0;
        }

        .transcription-area h3 {
            font-size: 0.95em;
            color: #6b7280;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .transcription-text {
            width: 100%;
            min-height: 200px;
            border: 1px solid #e8e5e0;
            border-radius: 6px;
            padding: 12px;
            font-size: 0.95em;
            font-family: inherit;
            resize: vertical;
            background: white;
        }

        .transcription-text:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }

        .history-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e8e5e0;
        }

        .history-panel h2 {
            font-size: 1.1em;
            margin-bottom: 16px;
            color: #1a1a1a;
            font-weight: 600;
        }

        .answer-card {
            background: #faf9f7;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #e8e5e0;
        }

        .answer-question {
            font-weight: 500;
            color: #1a1a1a;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .answer-meta {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 12px;
        }

        .answer-text {
            color: #374151;
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 12px;
            white-space: pre-wrap;
        }

        .answer-actions {
            display: flex;
            gap: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        /* 질문 관리 스타일 */
        .manager-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
            gap: 16px;
        }

        .manager-header h2 {
            font-size: 1.5em;
            color: #1a1a1a;
            font-weight: 600;
        }

        .manager-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .file-input-wrapper input[type="file"] {
            display: none;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e8e5e0;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 600;
            color: #c97f66;
            margin-bottom: 4px;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9em;
        }

        .search-box {
            margin-bottom: 20px;
        }

        .search-box input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d8d4cf;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .search-box input:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }

        .management-section {
            background: white;
            padding: 24px;
            border-radius: 8px;
            border: 1px solid #e8e5e0;
            margin-bottom: 24px;
        }

        .management-header {
            margin-bottom: 20px;
        }

        .management-header h3 {
            font-size: 1.25em;
            margin-bottom: 8px;
            color: #1a1a1a;
            font-weight: 600;
        }

        .management-header p {
            font-size: 0.9em;
            color: #6b7280;
        }

        #category-list-new {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .category-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: #faf9f7;
            border: 1px solid #e8e5e0;
            border-radius: 6px;
        }

        .category-info-new {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .category-name-badge {
            font-weight: 500;
            padding: 4px 12px;
            background: white;
            border: 1px solid #d8d4cf;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .question-count-badge {
            font-size: 0.9em;
            color: #6b7280;
        }

        .accordion-item {
            border: 1px solid #e8e5e0;
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: #faf9f7;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-wrap: wrap; /* 모바일 대응 */
            gap: 12px; /* 모바일 대응 */
        }

        .accordion-header:hover {
            background: #f0ede8;
        }
        
        .accordion-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
            color: #1a1a1a;
            flex: 1;
            min-width: 150px; /* 줄바꿈 최소 너비 */
            overflow: hidden;
        }
        
        .accordion-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-icon {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }

        .accordion-header.active .toggle-icon {
            transform: rotate(90deg);
        }

        .accordion-content {
            display: none;
            padding: 16px;
            background: white;
            border-top: 1px solid #e8e5e0;
        }

        .question-list-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0ede8;
        }
        .question-list-item:last-child {
            border-bottom: none;
        }

        .question-number-new {
            color: #6b7280;
            font-size: 0.9em;
            width: 30px;
        }

        .question-text-view {
            flex: 1;
            color: #374151;
        }

        .inline-add-form {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px dashed #d8d4cf;
        }

        .inline-add-form input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d4cf;
            border-radius: 6px;
            font-size: 0.95em;
        }
        .inline-add-form input:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            animation: modal-fade-in 0.3s ease;
        }
        
        @keyframes modal-fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            padding: 24px 24px 16px;
            border-bottom: 1px solid #e8e5e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            font-size: 1.25em;
            font-weight: 600;
            color: #1a1a1a;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .close-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .modal-body {
            padding: 24px;
        }

        .modal form {
            padding: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d4cf;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: inherit;
        }

        .form-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #c97f66;
            box-shadow: 0 0 0 3px rgba(201, 127, 102, 0.1);
        }

        .modal-footer {
            padding: 16px 24px;
            background: #f9fafb;
            border-top: 1px solid #e8e5e0;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }


        .status-message {
            padding: 12px 16px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
            font-size: 0.95em;
        }

        .status-info {
            background: #e8f0f5;
            color: #2c5f7a;
            border: 1px solid #c5dae8;
        }

        .status-success {
            background: #e8f2e5;
            color: #4a6b42;
            border: 1px solid #c5ddc0;
        }

        .status-error {
            background: #f5e6e0;
            color: #8b5a3c;
            border: 1px solid #e8d5bc;
        }

        .warning-box {
            background: #fef3c7;
            border: 1px solid #fde68a;
            padding: 16px;
            border-radius: 6px;
            margin: 20px 40px 0;
            color: #92400e;
            font-size: 0.9em;
        }
        .warning-box code {
            background: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            color: #333;
        }

        @media (max-width: 768px) {
            .header, .tabs, .warning-box {
                padding-left: 20px;
                padding-right: 20px;
                margin-left: 0;
                margin-right: 0;
            }
            .header h1 {
                font-size: 1.1em;
            }
            .tab-content {
                padding: 24px 20px;
            }
            .btn-secondary {
                font-size: 0.85em;
                padding: 8px 12px;
            }
            .practice-layout {
                grid-template-columns: 1fr;
            }
            .tabs {
                overflow-x: auto;
            }
            .tab {
                white-space: nowrap;
            }
            .manager-header {
                flex-direction: column;
                align-items: stretch;
            }
            .manager-controls {
                width: 100%;
            }
            .manager-controls button,
            .manager-controls .file-input-wrapper {
                flex: 1;
            }
            .manager-controls .file-input-wrapper button {
                width: 100%;
            }
            #focus-question-text {
                font-size: 1.5em;
            }
            .category-list-item .category-name-badge {
                display: none;
            }
        }
        
        /* 집중 모드 스타일 */
        #focusModeContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            padding: 40px;
        }

        #focusModeContainer.active {
            display: flex;
            opacity: 1;
        }

        .focus-controls-top {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 12px;
        }

        #focusCategorySelect, #exitFocusBtn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }

        #focus-question-text {
            font-size: 2em;
            font-weight: 500;
            max-width: 800px;
            margin-bottom: 40px;
            min-height: 100px;
        }

        #focus-circle {
            width: 150px;
            height: 150px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-out, background-color 0.3s ease, border 0.3s ease;
            box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
        }

        #focus-circle:hover {
            transform: scale(1.05);
        }

        #focus-circle.waiting {
            animation: pulse-white 2s infinite;
        }

        #focus-circle.listening {
            background-color: #ffcdd2; /* 붉은색으로 변경 */
            border: 2px solid #e57373;   /* 테두리 추가 */
        }

        @keyframes pulse-white {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        #focus-status-text {
            margin-top: 30px;
            font-size: 1.1em;
            color: #aaa;
            height: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📝 면접 연습 프로그램</h1>
        </div>
        
        <div id="setupWarning" class="warning-box" style="display: none;">
            <strong>⚠️ 음성 인식을 사용하려면 로컬 서버 또는 HTTPS가 필요합니다!</strong><br>
            현재 <code>file://</code> 프로토콜로 실행 중이어서 음성 인식이 작동하지 않습니다.<br>
            <em>※ 음성 인식 없이 텍스트만 입력해서 사용하셔도 됩니다.</em>
        </div>

        <div style="padding: 12px 40px; margin: 0; display: none;" id="recognitionStatusBar">
            <div style="display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-radius: 6px; border-left: 4px solid;">
                <span id="recognitionStatusIcon" style="font-size: 1.2em;"></span>
                <span id="recognitionStatusText" style="font-weight: 500;"></span>
            </div>
        </div>


        <div class="tabs">
            <button class="tab active" onclick="switchTab('practice')">연습</button>
            <button class="tab" onclick="switchTab('questions')">질문 데이터베이스</button>
            <button class="tab" onclick="switchTab('answers')">답변 기록</button>
            <button class="tab" onclick="switchTab('stats')">통계</button>
        </div>

        <!-- 연습 탭 -->
        <div id="practice-tab" class="tab-content active">
            <div class="practice-layout">
                <div class="question-section">
                    <div class="category-selector">
                        <label>카테고리:</label>
                        <select id="categorySelect">
                            <option value="all">전체</option>
                        </select>
                    </div>

                    <div class="question-display" id="questionDisplay">
                        <div class="question-number">질문을 선택해주세요</div>
                        <div class="question-text">"새 질문" 버튼을 클릭하여 시작하세요</div>
                    </div>

                    <div class="controls">
                        <button class="btn-primary" onclick="getNewQuestion()">새 질문</button>
                        <button class="btn-record" id="recordBtn" onclick="toggleRecording()">녹음 시작</button>
                        <button class="btn-secondary" onclick="resetTimer()">타이머 리셋</button>
                    </div>

                    <div class="timer" id="timer">00:00</div>

                    <div class="transcription-area">
                        <h3>답변 내용 (수정 가능)</h3>
                        <textarea class="transcription-text" id="transcriptionText" placeholder="녹음을 시작하면 여기에 텍스트가 표시됩니다..."></textarea>
                    </div>

                    <div class="controls">
                        <button class="btn-success" onclick="saveAnswer()">답변 저장</button>
                        <button class="btn-secondary" onclick="clearTranscription()">내용 지우기</button>
                    </div>

                    <div id="statusMessage"></div>
                </div>

                <div class="history-panel">
                    <h2>최근 답변 (5개)</h2>
                    <div id="recentAnswers"></div>
                </div>
            </div>
        </div>

        <!-- 질문 관리 탭 -->
        <div id="questions-tab" class="tab-content">
            <div class="manager-header">
                <h2>질문 데이터베이스 관리</h2>
                <div class="manager-controls">
                    <button class="btn-secondary" onclick="exportAllPresets()">전체 프리셋 내보내기</button>
                    <div class="file-input-wrapper">
                        <input type="file" id="presetImportFile" accept=".json" onchange="importAllPresets(event)">
                        <button class="btn-secondary" onclick="document.getElementById('presetImportFile').click()">전체 프리셋 가져오기</button>
                    </div>
                </div>
            </div>
            
            <!-- 프리셋 관리 섹션 -->
            <div class="management-section">
                <div class="management-header">
                    <h3>프리셋 관리</h3>
                    <p>프리셋을 선택하여 연습할 질문 목록을 바꿀 수 있습니다. 질문/카테고리를 수정하면 현재 선택된 프리셋에 자동 저장됩니다.</p>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="addBlankPreset()">+ 빈 프리셋 추가</button>
                    <div class="file-input-wrapper">
                         <input type="file" id="singlePresetImportFile" accept=".json" onchange="importSinglePreset(event)">
                         <button class="btn-secondary" onclick="document.getElementById('singlePresetImportFile').click()">프리셋 파일 불러오기</button>
                    </div>
                </div>

                <!-- 저장된 프리셋 목록 -->
                <div id="presetCardsContainer">
                    <!-- 프리셋 카드들이 여기에 표시됩니다 -->
                </div>
            </div>
            
            <div class="management-section">
                <div class="management-header">
                    <h3>카테고리 관리 (현재 프리셋: <span id="currentPresetNameForCategory" style="color: #c97f66; font-weight: bold;"></span>)</h3>
                    <p>현재 활성화된 프리셋의 카테고리를 관리합니다.</p>
                </div>
                <div id="category-list-new">
                    <!-- 자바스크립트로 카테고리 목록이 생성됩니다. -->
                </div>
                <button class="btn-primary" onclick="openAddCategoryModal()">+ 새 카테고리 추가</button>
            </div>

            <div class="management-section">
                <div class="management-header">
                    <h3>질문 관리</h3>
                    <p>각 카테고리를 클릭하여 펼치거나 접을 수 있습니다.</p>
                </div>
                <div id="question-accordion-list">
                    <!-- 자바스크립트로 아코디언 목록이 생성됩니다. -->
                </div>
            </div>
        </div>

        <!-- 답변 관리 탭 -->
        <div id="answers-tab" class="tab-content">
            <div class="answer-manager">
                <div class="manager-header">
                    <h2>답변 기록 관리</h2>
                    <div class="manager-controls">
                        <button class="btn-primary" onclick="exportAnswers()">답변 내보내기</button>
                        <div class="file-input-wrapper">
                            <input type="file" id="answerImportFile" accept=".json" onchange="importAnswers(event)">
                            <button class="btn-secondary" onclick="document.getElementById('answerImportFile').click()">답변 가져오기</button>
                        </div>
                        <button class="btn-danger" onclick="clearAllAnswers()">전체 삭제</button>
                    </div>
                </div>

                <!-- 녹음 기능 토글 -->
                <div class="toggle-container">
                    <div style="flex: 1;">
                        <div class="toggle-label">🎙️ 음성 녹음 기능</div>
                        <div class="toggle-description">활성화하면 답변 시 음성이 녹음되어 다운로드할 수 있습니다. 오프라인에서도 녹음 가능합니다. (음성 인식은 인터넷 필요)</div>
                    </div>
                    <div class="toggle-switch" id="audioRecordingToggle" onclick="toggleAudioRecording()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>

                <div class="search-box">
                    <input type="text" id="answerSearch" placeholder="답변 검색..." oninput="filterAnswers()">
                </div>

                <div id="answerList"></div>
            </div>
        </div>

        <!-- 통계 탭 -->
        <div id="stats-tab" class="tab-content">
            <h2 style="margin-bottom: 24px; font-size: 1.5em;">연습 통계</h2>
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="statsQuestionsCount">0</div>
                    <div class="stat-label">현재 프리셋 질문 수</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statsCategoryCount">0</div>
                    <div class="stat-label">현재 프리셋 카테고리 수</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statsAnswersCount">0</div>
                    <div class="stat-label">저장된 답변</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statsPracticeTime">0</div>
                    <div class="stat-label">총 연습 시간 (분)</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 질문 추가/편집 모달 -->
    <div id="questionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">질문 추가</h3>
                <button class="close-btn" onclick="closeQuestionModal()">×</button>
            </div>
            <form id="questionForm" onsubmit="saveQuestion(event)">
                <div class="form-group">
                    <label>카테고리*</label>
                    <select id="questionCategory" required>
                    </select>
                </div>
                <div class="form-group">
                    <label>질문 내용*</label>
                    <textarea id="questionText" required placeholder="질문을 입력하세요..."></textarea>
                </div>
                <input type="hidden" id="questionId">
                <div class="controls">
                    <button type="submit" class="btn-success">저장</button>
                    <button type="button" class="btn-secondary" onclick="closeQuestionModal()">취소</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 카테고리 추가/편집 모달 -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="categoryModalTitle">카테고리 추가</h3>
                <button class="close-btn" onclick="closeCategoryModal()">×</button>
            </div>
            <form id="categoryForm" onsubmit="saveCategory(event)">
                <div class="form-group">
                    <label>카테고리 ID* (영문, 숫자, 언더스코어만 가능)</label>
                    <input type="text" id="categoryId" required pattern="[a-zA-Z0-9_]+" placeholder="예: personality">
                </div>
                <div class="form-group">
                    <label>카테고리 이름*</label>
                    <input type="text" id="categoryName" required placeholder="예: 인성/가치관">
                </div>
                <input type="hidden" id="editingCategoryId">
                <div class="controls">
                    <button type="submit" class="btn-success">저장</button>
                    <button type="button" class="btn-secondary" onclick="closeCategoryModal()">취소</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- 집중 모드 컨테이너 -->
    <div id="focusModeContainer">
        <div class="focus-controls-top">
            <select id="focusCategorySelect"></select>
            <button id="exitFocusBtn">나가기</button>
        </div>
        <div id="focus-question-text">
            집중 모드를 시작하려면 중앙의 원을 클릭하세요.
        </div>
        <div id="focus-circle"></div>
        <div id="focus-status-text"></div>
    </div>

    <!-- 커스텀 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3 id="confirmModalTitle">확인</h3>
                <button class="close-btn" onclick="hideConfirmModal()">×</button>
            </div>
            <div class="modal-body">
                <p id="confirmModalMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="confirmModalCancelBtn" class="btn-secondary" onclick="hideConfirmModal()">취소</button>
                <button id="confirmModalConfirmBtn" class="btn-primary">확인</button>
            </div>
        </div>
    </div>

    <!-- 커스텀 프롬프트 모달 -->
    <div id="promptModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 id="promptModalTitle">입력</h3>
                <button class="close-btn" onclick="hidePromptModal()">×</button>
            </div>
            <div class="modal-body">
                <p id="promptModalMessage" style="margin-bottom: 12px;"></p>
                <input type="text" id="promptModalInput" class="form-group" style="width: 100%;">
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="hidePromptModal()">취소</button>
                <button id="promptModalConfirmBtn" class="btn-primary">확인</button>
            </div>
        </div>
    </div>

    <script>
        // --- 기본 프리셋 데이터 ---
        const defaultPresetInterview = {
            name: "면접용 연습질문",
            timestamp: new Date().toISOString(),
            categories: { basic: "기본 질문", academic: "학업/탐구", personality: "인성/가치관", department: "학과/진로", technical: "전공 관련" },
            questions: { basic: ["간단하게 자기소개를 해주세요.", "자신의 장점을 구체적인 사례와 함께 말씀해주세요.", "자신의 단점은 무엇이고, 이를 극복하기 위해 어떤 노력을 하고 있나요?", "본 대학교, 본 학과에 지원한 동기는 무엇인가요?", "마지막으로 하고 싶은 말씀이 있으신가요?",], academic: ["고등학교에서 가장 열심히 공부한 과목과 그 이유는 무엇인가요?", "학생부에서 가장 인상 깊은 탐구활동을 소개해주세요.", "탐구활동을 하면서 가장 어려웠던 점과 극복 과정을 설명해주세요.", "학업 성적이 낮은 과목이 있다면 그 이유와 개선 노력을 말씀해주세요.", "고교 3년간 가장 의미 있었던 활동(성취)은 무엇인가요? 그 이유는 무엇인가요?", "자신만의 학습 방법이나 시간 관리 노하우가 있나요?"], personality: ["리더십을 발휘한 경험이 있나요? 구체적으로 설명해주세요.", "팀 프로젝트에서 리더 역할을 맡았던 경험을 구체적으로 설명해주세요.", "리더십과 팔로워십 중 자신은 어느 쪽에 더 가까운가요?", "갈등 상황에서 어떻게 대처하나요? 구체적인 사례를 들어 설명해주세요.", "타인과 의견이 다를 때 어떻게 조율하나요?", "모둠 활동에 제대로 참여하지 않는 친구가 있다면 어떻게 할건가요?", "친구가 어려움에 처했을 때 도와준 경험이 있나요?", "실패한 경험과 그로부터 배운 점을 말씀해주세요.", "지금까지 살아오면서 겪었던 가장 힘들었던 경험은 무엇이고 어떻게 극복했나요?", "스트레스를 받을 때 어떻게 해소하나요?", "새로운 환경에 적응하는 자신만의 방법이 있나요?", "최근에 읽은 책 중 가장 인상 깊었던 책과 그 이유를 말씀해주세요.", "존경하는 인물이 있다면 누구이며, 그 이유는 무엇인가요?", "봉사활동 중 가장 기억에 남는 활동이 있나요?", "가장 중요하게 생각하는 가치관은 무엇인가요?"], department: ["대학 입학 후 가장 먼저 하고 싶은 일은 무엇인가요?", "입학 후 학업계획을 말해주세요.", "10년 후 자신의 모습은 어떨 것 같나요?", "졸업 후 진로 계획은 어떻게 되나요?", "이 학과에서 가장 듣고 싶은 과목은 무엇인가요?", "이 학과에 지원하기 위해 어떤 노력을 했나요?"], technical: [], }
        };
        const defaultPresetDaily = {
            name: "일상용 연습질문",
            timestamp: new Date().toISOString(),
            categories: { ice_breaking: "가볍게 시작하기 (아이스브레이킹)", daily_life: "일상과 취미", preferences: "취향과 생각", imagination: "상상과 가정", reflection: "가벼운 회고와 기대" },
            questions: { ice_breaking: ["오늘 하루 어땠나요?", "여기까지 어떻게 오셨어요? 오는 길에 재미있는 일은 없었나요?", "요즘 가장 많이 듣는 노래는 무엇인가요?", "아침에 일어나서 가장 먼저 하는 일은 무엇인가요?", "지금 가장 먹고 싶은 음식이 있다면요?", "최근에 가장 크게 웃었던 적은 언제인가요?", "지금 기분은 어떠신가요?", "오늘 아침 식사는 무엇을 하셨나요?", "오늘 날씨 어떤가요? 날씨 때문에 기분이 영향 받는 편인가요?", "지금 입고 있는 옷 중에서 가장 마음에 드는 아이템은 무엇인가요?", "오늘 집 나오기 전에 가장 마지막으로 한 행동은 뭐였나요?", "이번 주에 가장 기대되는 일이 있나요?", "최근에 새로 시도해본 것이 있나요?", "요즘 가장 자주 쓰는 이모티콘이나 밈은 무엇인가요?", "아침형 인간인가요, 저녁형 인간인가요?", "오늘 아침에 꾼 꿈 기억나시나요?", "지금 이 순간 창밖을 보면 무엇이 보이나요?", "오늘 제일 먼저 만난 사람은 누구였나요?", "요즘 가장 자주 하는 생각은 무엇인가요?", "출근길/등교길에 주로 무엇을 하면서 시간을 보내나요?", "커피 vs 차, 오늘은 어느 쪽 기분인가요?", "주머니나 가방에 항상 가지고 다니는 물건이 있나요?", "오늘 가장 기억에 남는 대화가 있었나요?", "지금 핸드폰 배경화면은 무엇인가요?", "오늘 하루 중 가장 좋았던 순간은 언제였나요?"], daily_life: ["학교에서 가장 좋아하는 시간은 언제인가요? (점심시간, 특정 수업, 쉬는 시간 등)", "스트레스 받을 때 보통 어떻게 푸는 편인가요?", "주말에는 보통 무엇을 하면서 시간을 보내나요?", "가장 친한 친구에게 나를 소개해달라고 한다면, 뭐라고 할 것 같나요?", "요즘 새롭게 빠져있는 취미나 관심사가 있나요?", "나만의 '소확행'(소소하지만 확실한 행복)은 무엇인가요?", "공부하기 싫을 때 자신을 다독이는 특별한 방법이 있나요?", "하루 중 언제가 가장 기분이 좋은가요?", "잠들기 전 루틴이 있나요?", "점심시간에 주로 누구와 함께 시간을 보내나요?", "방 청소는 얼마나 자주 하는 편인가요?", "좋아하는 과목과 싫어하는 과목, 그리고 그 이유는?", "학원이나 도서관보다 집에서 공부하는 걸 선호하나요?", "휴대폰 사용 시간은 하루에 평균 얼마나 되나요?", "가족들과는 주로 어떤 대화를 나누나요?", "학교 끝나고 집에 가는 길에 들르는 단골 장소가 있나요?", "야식을 자주 먹는 편인가요? 주로 뭘 먹나요?", "혼자 있는 시간과 친구들과 있는 시간, 어느 쪽을 더 좋아하나요?", "일주일에 운동은 얼마나 하는 편인가요?", "아침에 일어나는 게 힘든 편인가요?", "지각을 자주 하는 편인가요, 아니면 항상 일찍 도착하는 편인가요?", "친구들 사이에서 어떤 역할인 것 같나요? (분위기 메이커, 리더, 경청자 등)", "게임을 즐기는 편인가요? 어떤 게임을 주로 하나요?", "요즘 유튜브에서 주로 어떤 영상을 보나요?", "배달 음식 vs 직접 요리, 어느 쪽을 더 선호하나요?", "SNS는 주로 어떤 플랫폼을 사용하나요?", "옷은 주로 어디서 구매하나요? 온라인 vs 오프라인?", "일기를 쓰거나 기록을 남기는 습관이 있나요?", "새벽까지 깨어있는 일이 자주 있나요? 주로 뭘 하나요?", "버스나 지하철에서 주로 무엇을 하며 시간을 보내나요?", "친구에게 고민 상담을 자주 하는 편인가요, 받는 편인가요?", "계획을 세워서 움직이는 타입인가요, 즉흥적인 타입인가요?", "과제나 시험 공부는 미리미리 하는 편인가요, 벼락치기 타입인가요?", "물건을 자주 잃어버리는 편인가요?", "친구들과 주로 어떤 활동을 하며 노나요?"], preferences: ["가장 좋아하는 계절과 그 이유는 무엇인가요?", "최근에 재미있게 본 영화나 드라마가 있나요? 어떤 점이 좋았나요?", "'인생 책'이라고 부를 만한 책이 있다면 소개해주세요.", "강아지 vs 고양이, 어느 쪽을 더 좋아하세요?", "가장 좋아하는 음식과 가장 싫어하는 음식은 무엇인가요?", "여행을 간다면 산과 바다 중 어디로 가고 싶으세요?", "유튜브 채널을 하나 추천해준다면요?", "세상에서 가장 맛있는 라면 끓이는 법을 설명해준다면?", "치킨은 후라이드 vs 양념, 어느 쪽인가요?", "좋아하는 음악 장르는 무엇인가요?", "영화관 vs 집에서 OTT, 영화는 어디서 보는 게 좋나요?", "새벽감성 vs 아침햇살, 어느 쪽이 더 좋은가요?", "더운 여름 vs 추운 겨울, 차라리 견딜 만한 쪽은?", "액션 영화 vs 로맨스 영화, 선호하는 장르는?", "단맛 vs 짠맛, 평소에 더 당기는 쪽은?", "아이스 아메리카노 vs 따뜻한 라떼?", "비 오는 날의 매력에 대해 어떻게 생각하나요?", "가장 좋아하는 색깔과 그 이유는?", "편의점 삼각김밥 vs 컵라면, 편의점 가면 꼭 사는 건?", "혼밥 vs 여럿이 먹기, 식사는 어떻게 하는 게 좋나요?", "도시 vs 시골, 살기에는 어디가 더 좋을까요?", "아침 일찍 vs 저녁 늦게, 생산성이 더 높은 시간대는?", "책 vs 영화, 같은 스토리라면 어떤 매체로 접하고 싶나요?", "조용한 카페 vs 북적이는 카페, 어느 분위기가 좋나요?", "창가 자리 vs 복도 자리, 교실이나 카페에서 어디 앉는 걸 선호하나요?", "익숙한 것 vs 새로운 것, 평소 어느 쪽을 더 선호하나요?", "가장 좋아하는 패스트푸드 메뉴는?", "운동화 vs 슬리퍼, 편한 신발은?", "공포 영화를 좋아하나요, 무서워하나요?", "초콜릿 vs 사탕, 단 것 중에서 고른다면?", "가장 좋아하는 숫자가 있나요?", "낮잠 vs 밤잠, 어느 쪽이 더 꿀잠인가요?", "팝송 vs 한국 노래, 평소에 더 자주 듣는 쪽은?", "피자는 도우가 얇은 게 좋나요, 두꺼운 게 좋나요?", "가장 좋아하는 간식은 무엇인가요?"], imagination: ["만약 하루 동안 투명인간이 될 수 있다면 무엇을 하고 싶나요?", "로또 1등에 당첨된다면 가장 먼저 하고 싶은 일 3가지는?", "딱 한 가지 초능력을 가질 수 있다면 어떤 능력을 원하세요?", "타임머신을 타고 과거로 돌아갈 수 있다면, 언제로 가서 무엇을 하고 싶나요?", "무인도에 딱 3가지만 가져갈 수 있다면 무엇을 가져갈 건가요?", "내가 만약 영화감독이라면, 어떤 장르의 영화를 만들고 싶나요?", "10년 전의 나에게 딱 한마디 해줄 수 있다면?", "자신을 동물에 비유한다면 어떤 동물과 닮았다고 생각하나요?", "하루 동안 다른 사람과 몸이 바뀐다면 누구와 바뀌고 싶나요?", "세상에서 모든 책을 단 한 권만 읽을 수 있다면?", "평생 한 가지 음식만 먹어야 한다면 무엇을 선택하겠어요?", "시간을 멈출 수 있다면 어떤 순간에 사용하고 싶나요?", "우주여행 vs 심해탐험, 기회가 주어진다면 어디로 가고 싶나요?", "내가 만약 가수라면 어떤 노래를 부르고 싶나요?", "평생 여름 vs 평생 겨울, 하나를 선택해야 한다면?", "백만 원 vs 백만 팔로워, 어느 쪽을 선택하시겠어요?", "하루 동안 역사 속 인물이 될 수 있다면 누가 되고 싶나요?", "나만의 식당을 연다면 어떤 컨셉으로 운영하고 싶나요?", "마법 주문을 하나 만들 수 있다면 어떤 주문을 만들겠어요?", "평생 잠을 안 자도 된다면 그 시간에 무엇을 하고 싶나요?", "세상의 모든 언어를 구사할 수 있다면 가장 먼저 누구와 대화하고 싶나요?", "내 인생을 영화로 만든다면 어떤 배우가 나를 연기하면 좋을까요?", "기억을 하나만 지울 수 있다면 어떤 기억을 지우고 싶나요?", "반대로, 절대 잊고 싶지 않은 기억은 무엇인가요?", "평생 봄 날씨로 살 수 있다면 좋을 것 같나요?", "내가 만약 웹툰 작가라면 어떤 장르의 작품을 그리고 싶나요?", "세상에서 하나의 규칙을 만들 수 있다면 어떤 규칙을 만들겠어요?", "미래의 나에게서 편지가 온다면 어떤 내용이 쓰여 있을 것 같나요?", "24시간 동안 세상 모든 사람이 내 말을 듣는다면 무슨 말을 하고 싶나요?", "평생 실내 vs 평생 실외, 하나만 선택해야 한다면?", "내가 만약 대통령이라면 가장 먼저 하고 싶은 일은?", "공룡시대 vs 미래세계, 하루 동안 여행 간다면 어디로?", "내 인생의 사운드트랙을 한 곡 고른다면?", "평생 혼자 vs 평생 누군가와 함께, 어느 쪽이 더 나을까요?", "나를 향기로 표현한다면 어떤 향일 것 같나요?"], reflection: ["고등학교 3년을 한 단어로 표현한다면?", "고등학교 생활 중 가장 기억에 남는 '순간'은 언제인가요?", "대학교에 가면 가장 기대되는 것은 무엇인가요? (학업 외적으로)", "지금까지 살면서 가장 '잘했다'고 생각하는 선택은 무엇인가요?", "반대로, '아 그때는 좀 아쉬웠다'고 생각하는 순간이 있나요?", "가장 최근에 누군가에게 '고맙다'고 말했던 경험에 대해 이야기해주세요.", "1년 뒤, 나는 어떤 모습이었으면 좋겠나요?", "오늘 면접 연습이 끝나면 무엇을 할 계획인가요?", "나에게 가장 큰 영향을 준 사람은 누구인가요?", "최근 1년 동안 가장 많이 성장했다고 느끼는 부분은?", "어렸을 때의 나와 지금의 나, 가장 달라진 점은 무엇인가요?", "나만의 특별한 장점이라고 생각하는 것은?", "개선하고 싶은 나의 습관이 있나요?", "누군가에게 받은 말 중 가장 기억에 남는 말은?", "내가 스스로에게 자주 하는 말이 있나요?", "힘들 때 나를 지탱해주는 것은 무엇인가요?", "가장 뿌듯했던 순간을 떠올려본다면?", "지금의 내가 과거의 나에게 해주고 싶은 조언은?", "올해 안에 꼭 이루고 싶은 목표가 있나요?", "나를 가장 잘 표현하는 단어 3가지는?", "친구들이 나를 어떻게 기억해주길 바라나요?", "최근에 내가 변했다고 느낀 순간이 있나요?", "나에게 '집'이란 어떤 의미인가요?", "가장 소중하게 간직하고 있는 물건은 무엇인가요?", "10년 후의 나는 어떤 일을 하고 있을까요?", "지금까지 가장 용기 있는 결정은 무엇이었나요?", "나를 행복하게 만드는 것들을 나열해본다면?", "후회하는 일이 있다면 무엇인가요?", "꼭 지키려고 노력하는 나만의 원칙이 있나요?", "내가 생각하는 '성공'의 의미는 무엇인가요?", "스스로에게 칭찬해주고 싶은 점이 있나요?", "5년 전의 나는 지금의 나를 보고 어떻게 생각할까요?", "나에게 가족이란 어떤 존재인가요?", "가장 최근에 새롭게 깨달은 것이 있나요?", "내가 정말 좋아하는 것과 잘하는 것이 일치하나요?", "인생에서 가장 중요하게 생각하는 가치는 무엇인가요?", "지금 이 순간, 나에게 필요한 것은 무엇일까요?", "최근에 감사했던 순간을 떠올려본다면?", "앞으로의 인생에서 꼭 해보고 싶은 것이 있나요?", "나를 가장 잘 아는 사람은 누구일까요?"] }
        };
        
        // 전역 변수
        let categories = {};
        let questions = {};
        let answers = [];
        let presets = [];
        let activePresetName = null;
        let currentQuestion = null;
        let isRecording = false;
        let recognition = null;
        let timerInterval = null;
        let seconds = 0;
        let editingQuestionId = null;
        let koreanVoice = null; // TTS 목소리 저장 변수
        
        // 집중 모드 관련 전역 변수
        let isInFocusMode = false;
        let focusState = 'idle'; // idle -> waiting -> listening -> processing
        const FOCUS_DELAY = 500;

        // 음성 녹음 관련 전역 변수
        let audioRecordingEnabled = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let currentAudioBlob = null;
        let audioStream = null;

        // 초기화
        function init() {
            loadInitialData();
            loadAnswersFromStorage();
            loadAudioRecordingState();
            
            updateAllUIs();
            updateAnswerList();
            
            initSpeechRecognition();
            createFocusModeButton();
            loadKoreanVoice();
        }

        function createFocusModeButton() {
            const focusModeBtn = document.createElement('button');
            focusModeBtn.className = 'btn-secondary';
            focusModeBtn.textContent = '집중 모드';
            focusModeBtn.onclick = enterFocusMode;
            document.querySelector('.header').appendChild(focusModeBtn);
        }
        
        function loadKoreanVoice() {
            const setVoice = () => {
                const voices = window.speechSynthesis.getVoices();
                koreanVoice = voices.find(voice => voice.lang === 'ko-KR' && voice.name.includes('Online')) || 
                            voices.find(voice => voice.lang === 'ko-KR');
            };
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = setVoice;
            }
            setVoice();
        }

        // --- 데이터 관리 (프리셋 중심) ---
        function loadInitialData() {
            const savedPresets = localStorage.getItem('interviewPresets');
            const savedActivePreset = localStorage.getItem('activePresetName');

            if (savedPresets) {
                presets = JSON.parse(savedPresets);
            } else {
                // 첫 방문 시 기본 프리셋 생성
                presets = [
                    JSON.parse(JSON.stringify(defaultPresetInterview)),
                    JSON.parse(JSON.stringify(defaultPresetDaily))
                ];
                savePresetsToStorage();
            }

            // 활성 프리셋 설정
            if (savedActivePreset && presets.some(p => p.name === savedActivePreset)) {
                activePresetName = savedActivePreset;
            } else if (presets.length > 0) {
                activePresetName = presets[0].name; // 기본값으로 첫 번째 프리셋
            }

            if (activePresetName) {
                loadPresetData(activePresetName);
            }
        }

        function loadPresetData(presetName) {
            const preset = presets.find(p => p.name === presetName);
            if (preset) {
                activePresetName = preset.name;
                categories = JSON.parse(JSON.stringify(preset.categories));
                questions = JSON.parse(JSON.stringify(preset.questions));
                localStorage.setItem('activePresetName', activePresetName);
                updateAllUIs();
            } else {
                console.error(`Preset "${presetName}" not found.`);
                // 폴백: 첫 번째 프리셋 로드
                if (presets.length > 0) {
                    loadPresetData(presets[0].name);
                }
            }
        }

        function savePresetsToStorage() {
            localStorage.setItem('interviewPresets', JSON.stringify(presets));
        }

        function updateActivePresetData() {
            if (!activePresetName) return;
            const presetIndex = presets.findIndex(p => p.name === activePresetName);
            if (presetIndex !== -1) {
                presets[presetIndex].categories = JSON.parse(JSON.stringify(categories));
                presets[presetIndex].questions = JSON.parse(JSON.stringify(questions));
                presets[presetIndex].timestamp = new Date().toISOString();
                savePresetsToStorage();
                updatePresetUI(); // 변경사항(시간, 질문 수 등) 즉시 반영
            }
        }

        function loadAnswersFromStorage() {
            const storedAnswers = localStorage.getItem('interviewAnswers');
            answers = storedAnswers ? JSON.parse(storedAnswers) : [];
        }
        function saveAnswersToStorage() { localStorage.setItem('interviewAnswers', JSON.stringify(answers)); }

        // --- UI 렌더링 ---
        function updateAllUIs() {
            updatePresetUI();
            renderCategoryManagement();
            renderQuestionAccordion();
            updateCategorySelectors();
            updateRecentAnswers();
            updateStats();
            document.getElementById('currentPresetNameForCategory').textContent = activePresetName || '없음';
        }

        function renderCategoryManagement() {
            const container = document.getElementById('category-list-new');
            if (!container) return;
            
            container.innerHTML = Object.entries(categories).map(([id, name]) => `
                <div class="category-list-item">
                    <div class="category-info-new">
                        <span class="category-name-badge">${id}</span>
                        <span>${name}</span>
                        <span class="question-count-badge">${(questions[id] || []).length}개 질문</span>
                    </div>
                    <div class="answer-actions">
                        <button class="btn-secondary btn-small" onclick='editCategory("${id}")'>수정</button>
                        <button class="btn-danger btn-small" onclick='deleteCategory("${id}")'>삭제</button>
                    </div>
                </div>
            `).join('');
        }

        function renderQuestionAccordion() {
            const container = document.getElementById('question-accordion-list');
            if (!container) return;

            container.innerHTML = Object.entries(categories).map(([id, name]) => {
                const questionList = questions[id] || [];
                const questionsHtml = questionList.map((q, index) => `
                    <div class="question-list-item">
                        <span class="question-number-new">${index + 1}.</span>
                        <span class="question-text-view">${q}</span>
                        <div class="answer-actions">
                            <button class="btn-secondary btn-small btn-icon" onclick='editQuestion("${id}", ${index})' title="수정">✏️</button>
                            <button class="btn-danger btn-small btn-icon" onclick='deleteQuestion("${id}", ${index})' title="삭제">🗑️</button>
                        </div>
                    </div>
                `).join('');

                return `
                    <div class="accordion-item">
                        <div class="accordion-header" onclick="toggleAccordion(this)" data-category-id="${id}">
                            <div class="accordion-header-left">
                                <span class="toggle-icon">▶</span>
                                <span>${name}</span>
                                <span class="question-count-badge">${questionList.length}개</span>
                            </div>
                            <div class="accordion-header-right">
                                <button class="btn-primary btn-small" onclick="event.stopPropagation(); openAddQuestionModal('${id}');">+</button>
                            </div>
                        </div>
                        <div class="accordion-content" id="content-${id}">
                            ${questionsHtml.length > 0 ? questionsHtml : '<p style="color: #6b7280; text-align: center; padding: 10px 0;">질문이 없습니다.</p>'}
                            <form class="inline-add-form" onsubmit="inlineAddQuestion(event, '${id}')">
                                <input type="text" placeholder="새 질문을 입력하고 Enter를 누르세요..." required>
                            </form>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleAccordion(headerElement) {
            headerElement.classList.toggle('active');
            const content = headerElement.nextElementSibling;
            content.style.display = content.style.display === "block" ? "none" : "block";
        }

        function inlineAddQuestion(event, categoryId) {
            event.preventDefault();
            const input = event.target.querySelector('input');
            const newQuestion = input.value.trim();
            if (newQuestion) {
                if (!questions[categoryId]) questions[categoryId] = [];
                questions[categoryId].push(newQuestion);
                updateActivePresetData();
                renderQuestionAccordion();
                updateStats();
                input.value = '';
                const header = document.querySelector(`.accordion-header[data-category-id="${categoryId}"]`);
                if (header && !header.classList.contains('active')) toggleAccordion(header);
            }
        }

        // --- 카테고리 관리 ---
        function openAddCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = '카테고리 추가';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').disabled = false;
            document.getElementById('editingCategoryId').value = '';
            document.getElementById('categoryModal').classList.add('active');
        }

        function editCategory(categoryId) {
            document.getElementById('categoryModalTitle').textContent = '카테고리 편집';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = categoryId;
            document.getElementById('categoryId').disabled = true;
            document.getElementById('categoryName').value = categories[categoryId];
            document.getElementById('editingCategoryId').value = categoryId;
            document.getElementById('categoryModal').classList.add('active');
        }

        function closeCategoryModal() { document.getElementById('categoryModal').classList.remove('active'); }

        function saveCategory(event) {
            event.preventDefault();
            const categoryId = document.getElementById('categoryId').value.trim();
            const categoryName = document.getElementById('categoryName').value.trim();
            const oldCategoryId = document.getElementById('editingCategoryId').value;

            if (!categoryId || !categoryName) return;
            if (!oldCategoryId && categories[categoryId]) {
                showStatus('이미 존재하는 카테고리 ID입니다.', 'error');
                return;
            }

            if (oldCategoryId) categories[oldCategoryId] = categoryName;
            else {
                categories[categoryId] = categoryName;
                if (!questions[categoryId]) questions[categoryId] = [];
            }
            updateActivePresetData();
            updateAllUIs();
            closeCategoryModal();
        }

        function deleteCategory(categoryId) {
            const questionCount = (questions[categoryId] || []).length;
            const confirmMsg = questionCount > 0
                ? `이 카테고리에는 ${questionCount}개의 질문이 있습니다. 카테고리와 함께 모든 질문을 삭제하시겠습니까?`
                : `'${categories[categoryId]}' 카테고리를 삭제하시겠습니까?`;
            
            showConfirm(confirmMsg, () => {
                delete categories[categoryId];
                delete questions[categoryId];
                updateActivePresetData();
                updateAllUIs();
            });
        }
        
        // --- 질문 관리 ---
        function openAddQuestionModal(categoryId = null) {
            editingQuestionId = null;
            document.getElementById('modalTitle').textContent = '질문 추가';
            document.getElementById('questionForm').reset();
            document.getElementById('questionId').value = '';
            updateCategorySelectors(); // 최신 카테고리 목록 반영
            document.getElementById('questionCategory').value = categoryId || Object.keys(categories)[0] || '';
            document.getElementById('questionModal').classList.add('active');
        }

        function editQuestion(categoryId, index) {
            editingQuestionId = `${categoryId}-${index}`;
            document.getElementById('modalTitle').textContent = '질문 편집';
            document.getElementById('questionForm').reset();
            document.getElementById('questionCategory').value = categoryId;
            document.getElementById('questionText').value = questions[categoryId][index];
            document.getElementById('questionId').value = editingQuestionId;
            document.getElementById('questionModal').classList.add('active');
        }

        function closeQuestionModal() { document.getElementById('questionModal').classList.remove('active'); }

        function saveQuestion(event) {
            event.preventDefault();
            const categoryId = document.getElementById('questionCategory').value;
            const text = document.getElementById('questionText').value.trim();
            const questionId = document.getElementById('questionId').value;

            if (!text) return;
            if (!questions[categoryId]) questions[categoryId] = [];

            if (questionId) {
                const [oldCategoryId, index] = questionId.split('-');
                if (oldCategoryId === categoryId) {
                    questions[oldCategoryId][parseInt(index)] = text;
                } else {
                    questions[oldCategoryId].splice(parseInt(index), 1);
                    questions[categoryId].push(text);
                }
            } else {
                questions[categoryId].push(text);
            }
            updateActivePresetData();
            updateAllUIs();
            closeQuestionModal();
        }

        function deleteQuestion(categoryId, index) {
            questions[categoryId].splice(index, 1);
            updateActivePresetData();
            updateAllUIs();
        }
        
        // --- 음성 인식 ---
        function initSpeechRecognition() {
            if (window.location.protocol === 'file:') {
                document.getElementById('setupWarning').style.display = 'block';
                return;
            }
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                try {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = 'ko-KR';
                    recognition.maxAlternatives = 1;
                    let finalTranscript = '';
                    let lastFinalResultIndex = 0;

                    recognition.onstart = () => {
                        finalTranscript = document.getElementById('transcriptionText').value;
                        if (finalTranscript.length > 0 && !finalTranscript.endsWith(' ')) finalTranscript += ' ';
                        lastFinalResultIndex = 0;
                        showRecognitionStatus('음성 인식 활성화 - 말씀해주세요', '#7c9473', '●');
                    };

                    recognition.onresult = (event) => {
                        let interimTranscript = '';
                        for (let i = lastFinalResultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript + ' ';
                                lastFinalResultIndex = i + 1;
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        document.getElementById('transcriptionText').value = finalTranscript + interimTranscript;
                        if (interimTranscript) showRecognitionStatus(`🔊 인식 중...`, '#3b82f6', '●');
                    };

                    recognition.onerror = (event) => {
                        let errorMsg = '음성 인식 오류';
                        switch(event.error) {
                            case 'network': errorMsg = '네트워크 오류. 음성 인식은 중단되지만 녹음은 계속됩니다.'; break;
                            case 'not-allowed': errorMsg = '마이크 권한이 거부되었습니다. 권한을 허용해주세요.'; break;
                            case 'no-speech': errorMsg = '음성이 감지되지 않았습니다. 잠시 후 다시 시도합니다.'; break;
                            case 'audio-capture': errorMsg = '마이크를 찾을 수 없습니다.'; break;
                        }
                        showStatus(errorMsg, 'error');
                        showRecognitionStatus(errorMsg, '#ef4444', '!');
                        
                        if (event.error === 'not-allowed' || event.error === 'audio-capture') {
                            stopRecording();
                        }
                    };

                    recognition.onend = () => {
                        if (isRecording) {
                            try { 
                                if (navigator.onLine) recognition.start(); 
                            }
                            catch (e) { 
                                stopRecording(); 
                                showRecognitionStatus('⚠️ 재시작 실패', '#ef4444', '!'); 
                            }
                        } else {
                            showRecognitionStatus('음성 인식 대기 중', '#6b7280', '○');
                        }
                    };
                    showRecognitionStatus('음성 인식 준비 완료', '#10b981', '✓');
                } catch (e) {
                    showStatus('음성 인식을 초기화할 수 없습니다.', 'error');
                    showRecognitionStatus('❌ 초기화 실패', '#ef4444', '!');
                }
            } else {
                showStatus('이 브라우저는 음성 인식을 지원하지 않습니다.', 'error');
                showRecognitionStatus('❌ 브라우저 미지원', '#ef4444', '!');
            }
        }

        function showRecognitionStatus(message, color, icon) {
            const statusBar = document.getElementById('recognitionStatusBar');
            const statusText = document.getElementById('recognitionStatusText');
            const statusIcon = document.getElementById('recognitionStatusIcon');
            
            if (statusBar) {
                statusBar.style.display = 'block';
                const wrapper = statusBar.querySelector('div');
                wrapper.style.backgroundColor = color + '20';
                wrapper.style.borderColor = color;
                statusText.textContent = message;
                statusText.style.color = color;
                statusIcon.textContent = icon;
                statusIcon.style.color = color;
            }
        }

        function toggleRecording() {
            if (!currentQuestion) {
                showStatus('먼저 질문을 선택해주세요.', 'error');
                return;
            }
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            isRecording = true;
            
            if (recognition && navigator.onLine) {
                try {
                    recognition.start();
                } catch (e) {
                    console.warn("음성 인식을 시작할 수 없습니다:", e);
                    showStatus('음성 인식은 시작되지 않았지만, 녹음은 계속됩니다.', 'info');
                }
            } else if (!navigator.onLine) {
                showRecognitionStatus('오프라인 - 녹음만 진행', '#6b7280', '⌿');
            }

            if (audioRecordingEnabled) {
                startAudioRecording();
            }
            
            if (!isInFocusMode) {
                document.getElementById('recordBtn').textContent = '녹음 중지';
                document.getElementById('recordBtn').classList.add('recording');
                
                let statusMsg = "녹음이 시작되었습니다.";
                if (!navigator.onLine && audioRecordingEnabled) {
                    statusMsg = "오프라인 상태입니다. 음성만 녹음됩니다.";
                } else if (!navigator.onLine && !audioRecordingEnabled) {
                    statusMsg = "오프라인 상태입니다. 답변을 직접 입력해주세요.";
                }
                showStatus(statusMsg, 'info');

                startTimer();
            }
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false; 

            if (recognition) recognition.stop();
            if (audioRecordingEnabled && mediaRecorder && mediaRecorder.state !== 'inactive') stopAudioRecording();
            
            if (!isInFocusMode) {
                document.getElementById('recordBtn').textContent = '녹음 시작';
                document.getElementById('recordBtn').classList.remove('recording');
                stopTimer();
                if (document.getElementById('transcriptionText').value.trim()) {
                    showStatus('녹음이 중지되었습니다. 답변을 확인하고 저장하세요.', 'success');
                }
            }
        }

        // --- 음성 녹음 기능 ---
        function loadAudioRecordingState() {
            const saved = localStorage.getItem('audioRecordingEnabled');
            audioRecordingEnabled = saved === 'true';
            updateAudioRecordingToggle();
        }

        function toggleAudioRecording() {
            audioRecordingEnabled = !audioRecordingEnabled;
            localStorage.setItem('audioRecordingEnabled', audioRecordingEnabled.toString());
            updateAudioRecordingToggle();
            showStatus(audioRecordingEnabled ? '음성 녹음 기능이 활성화되었습니다.' : '음성 녹음 기능이 비활성화되었습니다.', 'success');
        }

        function updateAudioRecordingToggle() {
            const toggle = document.getElementById('audioRecordingToggle');
            if (toggle) {
                if (audioRecordingEnabled) toggle.classList.add('active');
                else toggle.classList.remove('active');
            }
        }

        async function startAudioRecording() {
            try {
                audioChunks = [];
                currentAudioBlob = null;
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
                mediaRecorder = new MediaRecorder(audioStream, { mimeType });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    currentAudioBlob = new Blob(audioChunks, { type: mimeType });
                    audioChunks = [];
                    if (audioStream) audioStream.getTracks().forEach(track => track.stop());
                    audioStream = null;
                };
                mediaRecorder.start();
            } catch (error) {
                console.error('Audio recording error:', error);
                showStatus('오디오 녹음을 시작할 수 없습니다. 마이크 권한을 확인하세요.', 'error');
            }
        }

        function stopAudioRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function downloadAudio(audioData, timestamp) {
            try {
                const byteString = atob(audioData.split(',')[1]);
                const mimeString = audioData.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
                const blob = new Blob([ab], { type: mimeString });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `answer_${timestamp}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                showStatus('오디오 다운로드 중 오류가 발생했습니다.', 'error');
            }
        }

        function playAudio(audioData, buttonElement) {
            try {
                const existingAudio = document.querySelector('audio.playing-audio');
                if (existingAudio) {
                    existingAudio.pause();
                    existingAudio.remove();
                }

                const audio = new Audio(audioData);
                audio.className = 'playing-audio';
                audio.play();
                buttonElement.textContent = '⏸️ 일시정지';
                buttonElement.onclick = () => pauseAudio(audio, buttonElement, audioData);
                audio.onended = () => {
                    buttonElement.textContent = '▶️ 재생';
                    buttonElement.onclick = () => playAudio(audioData, buttonElement);
                    audio.remove();
                };
            } catch (error) {
                console.error('Play error:', error);
                showStatus('오디오 재생 중 오류가 발생했습니다.', 'error');
            }
        }

        function pauseAudio(audio, buttonElement, audioData) {
            audio.pause();
            buttonElement.textContent = '▶️ 재생';
            buttonElement.onclick = () => resumeAudio(audio, buttonElement, audioData);
        }

        function resumeAudio(audio, buttonElement, audioData) {
            audio.play();
            buttonElement.textContent = '⏸️ 일시정지';
            buttonElement.onclick = () => pauseAudio(audio, buttonElement, audioData);
        }

        // --- 기타 유틸리티 함수 ---
        function switchTab(tabName) {
            document.querySelectorAll('.tab.active, .tab-content.active').forEach(el => el.classList.remove('active'));
            const clickedTab = Array.from(document.querySelectorAll('.tab')).find(tab => tab.getAttribute('onclick').includes(`'${tabName}'`));
            if(clickedTab) clickedTab.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            if (tabName === 'answers') updateAnswerList();
            if (tabName === 'questions') updateAllUIs();
        }
        
        function updateCategorySelectors() {
            const selectors = [document.getElementById('categorySelect'), document.getElementById('questionCategory'), document.getElementById('focusCategorySelect')];
            const categoryOptions = Object.entries(categories).map(([id, name]) => `<option value="${id}">${name}</option>`).join('');
            
            selectors.forEach(selector => {
                if (selector) {
                    const currentVal = selector.value;
                    let firstOption = '';
                    if (selector.id === 'categorySelect' || selector.id === 'focusCategorySelect') {
                        firstOption = '<option value="all">전체</option>';
                    }
                    selector.innerHTML = firstOption + categoryOptions;
                    // 기존 값이 유효하면 유지, 아니면 기본값
                    if (Array.from(selector.options).some(opt => opt.value === currentVal)) {
                        selector.value = currentVal;
                    } else {
                        selector.value = selector.options[0]?.value || '';
                    }
                }
            });
        }

        function startTimer() {
            if (timerInterval) return;
            timerInterval = setInterval(() => {
                seconds++;
                updateTimerDisplay();
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = null;
        }

        function resetTimer() {
            stopTimer();
            seconds = 0;
            updateTimerDisplay();
        }

        function updateTimerDisplay() {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('timer').textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function getNewQuestion() {
            const category = document.getElementById('categorySelect').value;
            const availableQuestions = category === 'all' ? Object.values(questions).flat() : questions[category] || [];
            if (availableQuestions.length === 0) {
                showStatus('선택한 카테고리에 질문이 없습니다.', 'error');
                currentQuestion = null;
                document.getElementById('questionDisplay').innerHTML = `<div class="question-number">질문 없음</div><div class="question-text">선택한 카테고리에 질문이 없습니다.</div>`;
                return;
            }
            currentQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
            document.getElementById('questionDisplay').innerHTML = `<div class="question-number">질문 (${getQuestionCategory(currentQuestion, true)})</div><div class="question-text">${currentQuestion}</div>`;
            resetTimer();
            clearTranscription();
        }

        function getQuestionCategory(question, returnName = false) {
            for (const [categoryId, questionList] of Object.entries(questions)) {
                if (questionList.includes(question)) return returnName ? (categories[categoryId] || categoryId) : categoryId;
            }
            return returnName ? '기타' : 'unknown';
        }

        async function saveAnswer() {
            const transcription = document.getElementById('transcriptionText').value.trim();
            if (!currentQuestion) {
                if (!isInFocusMode) showStatus('질문을 먼저 선택해주세요.', 'error');
                return;
            }
            if (!transcription && !currentAudioBlob) {
                if (!isInFocusMode) showStatus('답변 내용이 비어있습니다.', 'error');
                return;
            }
            
            let audioData = null;
            if (audioRecordingEnabled && currentAudioBlob) {
                try { audioData = await blobToBase64(currentAudioBlob); } 
                catch (error) { console.error('Failed to convert audio:', error); }
            }
            
            const answer = {
                id: Date.now(),
                question: currentQuestion,
                answer: transcription,
                duration: seconds,
                timestamp: new Date().toISOString(),
                category: getQuestionCategory(currentQuestion, true),
                audioData: audioData
            };
            
            answers.unshift(answer);
            saveAnswersToStorage();
            updateAllUIs();
            if (!isInFocusMode) showStatus('답변이 저장되었습니다!', 'success');
            clearTranscription();
            resetTimer();
            currentAudioBlob = null;
        }

        function clearTranscription() { document.getElementById('transcriptionText').value = ''; }

        function updateRecentAnswers() {
            const container = document.getElementById('recentAnswers');
            if (!container) return;
            const recent = answers.slice(0, 5);
            if (recent.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>아직 저장된 답변이 없습니다.</p></div>';
                return;
            }
            container.innerHTML = recent.map(answer => `
                <div class="answer-card">
                    <div class="answer-question">${answer.question}</div>
                    <div class="answer-meta">${answer.category} | ${Math.floor(answer.duration / 60)}분 ${answer.duration % 60}초</div>
                </div>
            `).join('');
        }

        function updateAnswerList() {
            const container = document.getElementById('answerList');
            const searchTerm = document.getElementById('answerSearch')?.value.toLowerCase() || '';
            const filtered = answers.filter(a => !searchTerm || a.question.toLowerCase().includes(searchTerm) || a.answer.toLowerCase().includes(searchTerm));
            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>저장된 답변이 없습니다.</p></div>';
                return;
            }
            container.innerHTML = filtered.map((answer, index) => {
                const audioButtons = answer.audioData 
                    ? `<button class="btn-secondary btn-small" id="playBtn_${index}" onclick="playAudio('${answer.audioData.replace(/'/g, "\\'")}', this)">▶️ 재생</button>
                    <button class="btn-secondary btn-small" onclick="downloadAudio('${answer.audioData.replace(/'/g, "\\'")}', '${answer.timestamp}')">💾 다운로드</button>` 
                    : '';
                return `
                <div class="answer-card">
                    <div class="answer-question">${answer.question}</div>
                    <div class="answer-meta">카테고리: ${answer.category} | 시간: ${Math.floor(answer.duration / 60)}분 ${answer.duration % 60}초 | ${new Date(answer.timestamp).toLocaleString('ko-KR')}</div>
                    <div class="answer-text">${answer.answer.replace(/\n/g, '<br>')}</div>
                    <div class="answer-actions">
                        ${audioButtons}
                        <button class="btn-danger btn-small" onclick="deleteAnswer(${answer.id})">삭제</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        function filterAnswers() { updateAnswerList(); }

        function deleteAnswer(id) {
            showConfirm('이 답변을 삭제하시겠습니까?', () => {
                answers = answers.filter(a => a.id !== id);
                saveAnswersToStorage();
                updateAnswerList();
                updateAllUIs();
                showStatus('답변이 삭제되었습니다.', 'info');
            });
        }

        function clearAllAnswers() {
            if (answers.length > 0) {
                showConfirm('모든 답변 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.', () => {
                    answers = [];
                    saveAnswersToStorage();
                    updateAnswerList();
                    updateAllUIs();
                    showStatus('모든 답변이 삭제되었습니다.', 'info');
                });
            }
        }

        function exportAnswers() {
            if (answers.length === 0) {
                showStatus('내보낼 답변이 없습니다.', 'error');
                return;
            }
            const dataStr = JSON.stringify(answers, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `interview-answers-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importAnswers(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) throw new Error("Invalid format");

                    showConfirm('기존 답변을 덮어쓰시겠습니까? (취소하면 기존 답변에 추가됩니다)', 
                        () => { // 확인
                            answers = imported;
                            finishImport();
                        },
                        () => { // 취소
                            answers = [...answers, ...imported];
                            finishImport();
                        }
                    );
                    function finishImport() {
                        saveAnswersToStorage();
                        updateAnswerList();
                        updateAllUIs();
                        showStatus(`${imported.length}개의 답변을 가져왔습니다.`, 'success');
                    }
                } catch (error) { showStatus('파일을 읽는 중 오류가 발생했습니다.', 'error'); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function updateStats() {
            const totalQuestions = Object.values(questions).reduce((sum, list) => sum + list.length, 0);
            const categoryCount = Object.keys(categories).length;
            const totalAnswers = answers.length;
            const totalTime = answers.reduce((sum, a) => sum + a.duration, 0);
            const stats = {
                statsQuestionsCount: totalQuestions,
                statsCategoryCount: categoryCount,
                statsAnswersCount: totalAnswers,
                statsPracticeTime: Math.round(totalTime / 60),
            };
            for (const [id, value] of Object.entries(stats)) {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            if(!statusDiv) return;
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        // --- 집중 모드 ---
        function enterFocusMode() {
            document.getElementById('focusModeContainer').classList.add('active');
            isInFocusMode = true;
            updateCategorySelectors(); // 포커스 모드 셀렉터 업데이트
            resetFocusMode();
            clearTranscription();
        }

        function exitFocusMode() {
            if (isRecording) stopRecording();
            document.getElementById('focusModeContainer').classList.remove('active');
            isInFocusMode = false;
            resetFocusMode();
        }
        document.getElementById('exitFocusBtn').addEventListener('click', exitFocusMode);

        function resetFocusMode() {
            focusState = 'idle';
            document.getElementById('focus-question-text').textContent = '집중 모드를 시작하려면 중앙의 원을 클릭하세요.';
            document.getElementById('focus-status-text').textContent = '';
            const circle = document.getElementById('focus-circle');
            circle.classList.remove('waiting', 'listening');
        }

        function speak(text, callback) {
            if (!('speechSynthesis' in window)) {
                showStatus('이 브라우저는 음성 합성을 지원하지 않습니다.', 'error');
                if (callback) callback();
                return;
            }
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            if (koreanVoice) utterance.voice = koreanVoice;
            utterance.lang = 'ko-KR';
            utterance.rate = 1.0;
            utterance.onend = () => { if (callback) callback(); };
            window.speechSynthesis.speak(utterance);
        }

        function startFocusModeQuestion() {
            if (focusState !== 'idle') return;
            clearTranscription();
            resetTimer();

            const category = document.getElementById('focusCategorySelect').value;
            const availableQuestions = category === 'all' ? Object.values(questions).flat() : questions[category] || [];
            if (availableQuestions.length === 0) {
                document.getElementById('focus-question-text').textContent = '선택한 카테고리에 질문이 없습니다.';
                return;
            }
            currentQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
            document.getElementById('focus-question-text').textContent = currentQuestion;

            focusState = 'waiting';
            document.getElementById('focus-status-text').textContent = '질문을 들어보세요...';
            
            speak(currentQuestion, () => {
                const circle = document.getElementById('focus-circle');
                circle.classList.add('waiting');
                document.getElementById('focus-status-text').textContent = '답변을 준비하세요...';
                startTimer();

                setTimeout(() => {
                    circle.classList.remove('waiting');
                    circle.classList.add('listening');
                    document.getElementById('focus-status-text').textContent = '듣고 있습니다...';
                    startRecording();
                    focusState = 'listening';
                }, FOCUS_DELAY);
            });
        }

        function stopAndSaveAnswer() {
            if (focusState !== 'listening') return;
            
            focusState = 'processing';
            document.getElementById('focus-status-text').textContent = '답변을 처리 중입니다...';
            
            stopTimer();
            stopRecording();

            setTimeout(() => {
                saveAnswer();
                document.getElementById('focus-status-text').textContent = '답변이 저장되었습니다. 다시 시작하려면 원을 클릭하세요.';
                focusState = 'idle';
                document.getElementById('focus-circle').classList.remove('listening');
            }, 1000);
        }

        document.getElementById('focus-circle').addEventListener('click', () => {
            if (focusState === 'idle') startFocusModeQuestion();
            else if (focusState === 'listening') stopAndSaveAnswer();
        });

        // --- 프리셋 관리 (개선된 버전) ---
        function updatePresetUI() {
            const container = document.getElementById('presetCardsContainer');
            if (!container) return;
            
            if (presets.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>저장된 프리셋이 없습니다.</p></div>';
                return;
            }
            
            container.innerHTML = '<div class="preset-cards">' + presets.map((preset) => {
                const dateStr = new Date(preset.timestamp).toLocaleString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                const questionCount = Object.values(preset.questions).reduce((sum, list) => sum + list.length, 0);
                const categoryCount = Object.keys(preset.categories).length;
                const isActive = preset.name === activePresetName;
                
                return `
                    <div class="preset-card ${isActive ? 'active' : ''}" onclick="loadPresetData('${preset.name}')">
                        <div>
                            <div class="preset-card-header">
                                <div class="preset-card-title">${preset.name}</div>
                            </div>
                            <div class="preset-card-meta">
                                ${questionCount}개 질문 | ${categoryCount}개 카테고리<br>
                                ${dateStr}
                            </div>
                        </div>
                        <div class="preset-card-actions" onclick="event.stopPropagation()">
                            <button class="btn-secondary btn-small" onclick="exportPreset('${preset.name}')">다운로드</button>
                            <button class="btn-secondary btn-small" onclick="quickRenamePreset('${preset.name}')">이름 변경</button>
                            <button class="btn-secondary btn-small" onclick="duplicatePreset('${preset.name}')">복제</button>
                            <button class="btn-secondary btn-small" onclick="quickDeletePreset('${preset.name}')">삭제</button>
                        </div>
                    </div>
                `;
            }).join('') + '</div>';
        }

        function getNewPresetName() {
            const baseName = "새 프리셋";
            if (!presets.some(p => p.name === baseName)) {
                return baseName;
            }
            let num = 2;
            let newName = `${baseName} (${num})`;
            while (presets.some(p => p.name === newName)) {
                num++;
                newName = `${baseName} (${num})`;
            }
            return newName;
        }

        function addBlankPreset() {
            const newName = getNewPresetName();
            const preset = {
                name: newName,
                categories: {},
                questions: {},
                timestamp: new Date().toISOString()
            };
            presets.push(preset);
            savePresetsToStorage();
            updatePresetUI();
            showStatus(`'${newName}' 프리셋이 추가되었습니다.`, 'success');
        }

        function quickDeletePreset(presetName) {
            if (presets.length <= 1) {
                showStatus('마지막 프리셋은 삭제할 수 없습니다.', 'error');
                return;
            }
            showConfirm(`'${presetName}' 프리셋을 삭제하시겠습니까?`, () => {
                presets = presets.filter(p => p.name !== presetName);
                if (activePresetName === presetName) {
                    activePresetName = presets[0].name; // 다른 프리셋으로 활성화 전환
                    loadPresetData(activePresetName);
                }
                savePresetsToStorage();
                updateAllUIs();
                showStatus('프리셋이 삭제되었습니다.', 'info');
            });
        }

        function quickRenamePreset(oldName) {
            showPrompt('새 프리셋 이름을 입력하세요:', oldName, (newName) => {
                newName = newName.trim();
                if (!newName) return;
                
                if (presets.some(p => p.name === newName && p.name !== oldName)) {
                    showStatus('이미 존재하는 프리셋 이름입니다.', 'error');
                    return;
                }
                
                const preset = presets.find(p => p.name === oldName);
                if (preset) {
                    preset.name = newName;
                    if (activePresetName === oldName) {
                        activePresetName = newName;
                        localStorage.setItem('activePresetName', activePresetName);
                    }
                    savePresetsToStorage();
                    updateAllUIs();
                    showStatus('프리셋 이름이 변경되었습니다.', 'success');
                }
            });
        }
        
        function getDuplicatePresetName(originalName) {
            const baseName = `${originalName} 사본`;
            if (!presets.some(p => p.name === baseName)) {
                return baseName;
            }
            let num = 2;
            let newName = `${baseName} (${num})`;
            while (presets.some(p => p.name === newName)) {
                num++;
                newName = `${baseName} (${num})`;
            }
            return newName;
        }

        function duplicatePreset(presetNameToDuplicate) {
            const originalPreset = presets.find(p => p.name === presetNameToDuplicate);
            if (!originalPreset) {
                showStatus('복제할 프리셋을 찾을 수 없습니다.', 'error');
                return;
            }

            const newPreset = JSON.parse(JSON.stringify(originalPreset)); // Deep copy
            newPreset.name = getDuplicatePresetName(originalPreset.name);
            newPreset.timestamp = new Date().toISOString();

            presets.push(newPreset);
            savePresetsToStorage();
            updatePresetUI();
            showStatus(`'${originalPreset.name}' 프리셋이 '${newPreset.name}'(으)로 복제되었습니다.`, 'success');
        }

        function exportPreset(presetName) {
            const preset = presets.find(p => p.name === presetName);
            if (!preset) return;

            const dataStr = JSON.stringify(preset, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${preset.name}_preset.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importSinglePreset(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedPreset = JSON.parse(e.target.result);
                    if (!importedPreset.name || importedPreset.categories === undefined || importedPreset.questions === undefined) {
                        throw new Error("Invalid preset format");
                    }

                    if (presets.some(p => p.name === importedPreset.name)) {
                        showConfirm(`'${importedPreset.name}' 프리셋이 이미 존재합니다. 덮어쓰시겠습니까?`, () => {
                            const index = presets.findIndex(p => p.name === importedPreset.name);
                            presets[index] = importedPreset;
                            finishImport(importedPreset.name);
                        });
                    } else {
                        presets.push(importedPreset);
                        finishImport(importedPreset.name);
                    }
                } catch (error) {
                    showStatus('올바른 프리셋 파일이 아닙니다.', 'error');
                }
            };
            function finishImport(name) {
                savePresetsToStorage();
                updatePresetUI();
                showStatus(`프리셋 '${name}'을(를) 가져왔습니다.`, 'success');
            }
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportAllPresets() {
            const dataStr = JSON.stringify(presets, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `all_presets_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importAllPresets(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedPresets = JSON.parse(e.target.result);
                    if (!Array.isArray(importedPresets)) throw new Error("Invalid format");
                    
                    showConfirm('가져온 데이터로 모든 프리셋을 교체하시겠습니까?', () => {
                        presets = importedPresets;
                        activePresetName = presets.length > 0 ? presets[0].name : null;
                        savePresetsToStorage();
                        loadPresetData(activePresetName);
                        showStatus('모든 프리셋을 성공적으로 가져왔습니다.', 'success');
                    });
                } catch (error) { showStatus('파일을 읽는 중 오류가 발생했습니다.', 'error'); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }
        
        // --- 커스텀 모달 함수 ---
        function showConfirm(message, onConfirm, onCancel = () => {}) {
            document.getElementById('confirmModalMessage').innerHTML = message.replace(/\n/g, '<br>');
            const confirmBtn = document.getElementById('confirmModalConfirmBtn');
            const cancelBtn = document.getElementById('confirmModalCancelBtn');
            
            const confirmHandler = () => {
                hideConfirmModal();
                onConfirm();
            };
            const cancelHandler = () => {
                hideConfirmModal();
                onCancel();
            };

            confirmBtn.onclick = confirmHandler;
            cancelBtn.onclick = cancelHandler;
            
            document.getElementById('confirmModal').classList.add('active');
            confirmBtn.focus();
        }

        function hideConfirmModal() {
            document.getElementById('confirmModal').classList.remove('active');
        }

        function showPrompt(message, defaultValue, onConfirm) {
            document.getElementById('promptModalMessage').textContent = message;
            const input = document.getElementById('promptModalInput');
            input.value = defaultValue;
            
            const confirmBtn = document.getElementById('promptModalConfirmBtn');
            const confirmHandler = () => {
                hidePromptModal();
                onConfirm(input.value);
            };
            
            confirmBtn.onclick = confirmHandler;
            input.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    confirmHandler();
                }
            };
            
            document.getElementById('promptModal').classList.add('active');
            input.focus();
            input.select();
        }

        function hidePromptModal() {
            document.getElementById('promptModal').classList.remove('active');
        }

        document.addEventListener('DOMContentLoaded', init);
        document.querySelectorAll('.modal').forEach(modal => modal.addEventListener('click', (e) => { 
            if (e.target === modal) {
                modal.classList.remove('active');
            }
        }));

    </script>
</body>
</html>
